---
phase: 11-integration
plan: 01
type: execute
depends_on: []
files_modified: [src/main.tsx, src/surfaces/auth/AuthSurface.tsx]
---

<objective>
Wire up authentication state management in the App shell component.

Purpose: Connect the Preact app to real auth state so users can log in and out properly.
Output: App component that listens to auth state, handles initial session, and navigates between auth/dashboard.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/main.tsx
@src/surfaces/auth/AuthSurface.tsx
@src/services/auth.ts

**Relevant prior decisions:**
- AuthSurface already has internal auth state listener for password recovery flow
- Services use window.auth / window.* pattern (must remain compatible)
- Preact surfaces are fully functional, just need App-level coordination
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth state listener to App component</name>
  <files>src/main.tsx</files>
  <action>
Add auth state management to App component:

1. Import auth service: `import { auth } from '@/services/auth';`
2. Add state: `const [user, setUser] = useState<any>(null);`
3. Add state: `const [isLoading, setIsLoading] = useState(true);`
4. Add state: `const [isPasswordRecoveryMode, setIsPasswordRecoveryMode] = useState(false);`

5. Add useEffect for auth listener:
   - Call auth.onAuthStateChange with callback
   - On PASSWORD_RECOVERY: setIsPasswordRecoveryMode(true), setCurrentSurface('auth')
   - On SIGNED_IN: If not isPasswordRecoveryMode, setUser(session.user), setCurrentSurface('dashboard')
   - On SIGNED_OUT: setUser(null), setCurrentSurface('auth')
   - Store subscription and return cleanup function

6. Update handleLogout to actually call auth.logout():
   - await auth.logout()
   - Auth listener will handle navigation

Do NOT duplicate password recovery URL hash detection here - AuthSurface already handles it internally and will set its own sub-surface to 'updatePassword'.
  </action>
  <verify>npm run build succeeds, npx tsc --noEmit passes</verify>
  <done>App component has auth state listener that responds to SIGNED_IN, SIGNED_OUT, PASSWORD_RECOVERY events</done>
</task>

<task type="auto">
  <name>Task 2: Add initial session check on App mount</name>
  <files>src/main.tsx</files>
  <action>
Add initial session check to the App useEffect:

1. Before setting up auth listener, check URL hash for recovery mode:
   ```typescript
   const hashParams = new URLSearchParams(window.location.hash.substring(1));
   if (hashParams.get('type') === 'recovery') {
     setIsPasswordRecoveryMode(true);
     setCurrentSurface('auth');
   }
   ```

2. After setting up auth listener, check initial session:
   ```typescript
   const session = await auth.getSession();
   if (session?.user && !isPasswordRecoveryMode) {
     setUser(session.user);
     setCurrentSurface('dashboard');
   }
   setIsLoading(false);
   ```

3. Add loading screen render:
   - If isLoading is true, render a simple loading div
   - Match the existing styles: `<div class="loading-screen"><div class="loading-content"><h2>Loading...</h2></div></div>`

4. Don't render surfaces until isLoading is false.
  </action>
  <verify>npm run build succeeds, app shows loading screen then auth surface on fresh load, shows dashboard if already logged in</verify>
  <done>App checks initial session and shows loading screen during check</done>
</task>

<task type="auto">
  <name>Task 3: Add onLogin callback to AuthSurface</name>
  <files>src/surfaces/auth/AuthSurface.tsx, src/main.tsx</files>
  <action>
Wire AuthSurface to notify App when login succeeds:

In AuthSurface.tsx:
1. Add optional prop: `onLoginSuccess?: () => void`
2. In handleAuth, after successful login/register (result.error is falsy), call onLoginSuccess if provided
3. Note: Don't call onLoginSuccess on password update - that's handled separately

In main.tsx:
1. Pass onLoginSuccess to AuthSurface:
   ```tsx
   <AuthSurface onLoginSuccess={() => {
     // Auth listener will handle the actual navigation
     // This callback is for any additional cleanup if needed
   }} />
   ```

Actually, the auth listener should handle navigation automatically when SIGNED_IN fires. The onLoginSuccess callback isn't strictly necessary if the auth listener is working. Test without it first.

Alternative approach: Just rely on the auth listener. When auth.login() succeeds, Supabase fires SIGNED_IN, our listener catches it, and navigates to dashboard. No callback needed.

Choose the simpler approach: Don't add onLoginSuccess callback. Let the auth listener handle everything.

Verify the flow works:
1. User on auth surface
2. User logs in successfully
3. Supabase fires SIGNED_IN
4. Auth listener in App catches it
5. App sets currentSurface to 'dashboard'
  </action>
  <verify>User can log in from auth surface and automatically navigate to dashboard</verify>
  <done>Login flow works end-to-end: auth surface -> login -> SIGNED_IN event -> dashboard</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] Fresh page load shows loading screen, then auth surface
- [ ] User can log in and automatically navigate to dashboard
- [ ] User can log out and automatically navigate to auth surface
- [ ] Password recovery link opens update password form
</verification>

<success_criteria>
- Auth state listener functional in App
- Initial session check working
- Login/logout navigation works via auth events
- Password recovery mode handled correctly
</success_criteria>

<output>
After completion, create `.planning/phases/11-integration/11-01-SUMMARY.md`
</output>
