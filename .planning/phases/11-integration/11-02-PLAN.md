---
phase: 11-integration
plan: 02
type: execute
depends_on: ["11-01"]
files_modified: [src/main.tsx]
---

<objective>
Add workout state restoration on app load.

Purpose: If user had an active workout saved in localStorage (from previous session or another tab), restore it when the app loads.
Output: App checks for saved workout after auth confirms, navigates to workout surface if found.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-integration/11-01-SUMMARY.md
@src/main.tsx
@src/surfaces/workout/WorkoutSurface.tsx

**Relevant prior work:**
- Phase 09-05: WorkoutSurface has localStorage backup and multi-tab sync
- localStorage key format: `activeWorkout_{user_id}`
- Backup data structure: { activeWorkout, originalTemplateSnapshot, last_saved_at }
- WorkoutSurface already handles storage event listener for cross-tab sync
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workout restoration check on App mount</name>
  <files>src/main.tsx</files>
  <action>
After auth is confirmed and user is logged in, check for saved workout:

1. Create helper function to check localStorage:
   ```typescript
   const checkForSavedWorkout = (userId: string): SavedWorkoutData | null => {
     const key = `activeWorkout_${userId}`;
     const stored = localStorage.getItem(key);
     if (!stored) return null;

     try {
       const data = JSON.parse(stored);
       // Validate required fields
       if (!data.activeWorkout?.started_at ||
           !Array.isArray(data.activeWorkout?.exercises) ||
           data.activeWorkout.exercises.length === 0) {
         localStorage.removeItem(key);
         return null;
       }
       return data;
     } catch (e) {
       localStorage.removeItem(key);
       return null;
     }
   };
   ```

2. Add type for saved workout data (or use any):
   ```typescript
   interface SavedWorkoutData {
     activeWorkout: {
       template_id: string | null;
       template_name: string;
       started_at: string;
       exercises: any[];
     };
     originalTemplateSnapshot: any;
     last_saved_at: string;
   }
   ```

3. In the initial session check (after setUser and setCurrentSurface('dashboard')):
   - Check for saved workout: `const savedWorkout = checkForSavedWorkout(session.user.id);`
   - If found: Set state to navigate to workout surface with restored data
   - This requires either:
     a) Storing restored workout in App state and passing to WorkoutSurface
     b) WorkoutSurface checking localStorage on mount (it may already do this)

Check WorkoutSurface to see if it loads from localStorage on mount. If yes, just navigate to workout surface. If no, need to pass restored data.
  </action>
  <verify>npm run build succeeds</verify>
  <done>App has helper function to check for saved workout in localStorage</done>
</task>

<task type="auto">
  <name>Task 2: Navigate to WorkoutSurface with restored state</name>
  <files>src/main.tsx</files>
  <action>
Wire up restoration to navigate to workout surface:

1. Check if WorkoutSurface loads from localStorage on mount:
   - Looking at WorkoutSurface.tsx, it initializes workout from `template` prop
   - It does NOT load from localStorage on mount (that was in Alpine's restoreWorkoutFromStorage)

2. Two approaches:

   **Option A (Simpler):** Pass restored workout data via special prop
   - Add `restoredWorkout?: SavedWorkoutData` prop to WorkoutSurface
   - If restoredWorkout provided, use it instead of initializing from template
   - Modify WorkoutSurface to accept this

   **Option B (Cleaner):** WorkoutSurface loads from localStorage on mount
   - WorkoutSurface checks localStorage in useEffect
   - If found, initializes state from localStorage instead of template
   - Requires knowing user ID (pass via context or prop)

Go with Option A - it's more explicit:

3. In App component:
   - Add state: `const [restoredWorkoutData, setRestoredWorkoutData] = useState<SavedWorkoutData | null>(null);`
   - When saved workout found, set: `setRestoredWorkoutData(savedWorkout);`
   - Set currentSurface to 'workout'
   - Pass to WorkoutSurface: `restoredWorkout={restoredWorkoutData}`

4. Modify WorkoutSurface to accept restoredWorkout prop (brief change):
   - Add prop: `restoredWorkout?: SavedWorkoutData`
   - In initialization, if restoredWorkout provided, use it instead of template

5. Clear restoredWorkoutData when workout finishes or cancels.

Actually, simpler approach: Create a fake TemplateWithExercises from the restored data and pass as template prop. WorkoutSurface already handles template. The restored workout has all the data needed.

Wait - WorkoutSurface needs the original template to detect changes (hasTemplateChanges). The restored data has originalTemplateSnapshot. Need to preserve that.

Best approach: Add an optional `restoredWorkout` prop to WorkoutSurface that includes both activeWorkout and originalTemplateSnapshot. WorkoutSurface initializes from this if provided, otherwise from template.
  </action>
  <verify>npm run build succeeds, saved workout is restored on app reload</verify>
  <done>Saved workout in localStorage is restored when app loads, user sees workout surface with previous state</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] User with active workout can close browser, reopen, and see workout restored
- [ ] Workout state (exercises, sets, timer) is preserved
- [ ] If no saved workout, user sees dashboard normally
</verification>

<success_criteria>
- Saved workout detection works on app load
- Workout surface shows with restored state
- Normal flow (no saved workout) still works
</success_criteria>

<output>
After completion, create `.planning/phases/11-integration/11-02-SUMMARY.md`
</output>
