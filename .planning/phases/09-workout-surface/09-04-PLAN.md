---
phase: 09-workout-surface
plan: 04
type: execute
depends_on: ["09-03"]
files_modified: [src/surfaces/workout/SetRow.tsx, src/surfaces/workout/WorkoutSurface.tsx, src/surfaces/workout/WorkoutExerciseCard.tsx]
---

<objective>
Implement swipe-to-delete gesture handling for set rows.

Purpose: Enable users to swipe left on set rows to reveal delete button (mobile-friendly pattern).
Output: SetRow component with pointer/touch event handlers for swipe gesture detection.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-workout-surface/09-03-SUMMARY.md

# Existing code to migrate:
@js/app.js (lines 773-896: handleSwipeStart, handleSwipeMove, handleSwipeEnd, handleSwipeCancel, deleteSetWithSwipeReset)
@index.html (lines 569-616: set row wrapper with pointer events)

# Current workout surface:
@src/surfaces/workout/SetRow.tsx
@src/surfaces/workout/WorkoutSurface.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add swipe state and handlers to SetRow</name>
  <files>src/surfaces/workout/SetRow.tsx</files>
  <action>
Add swipe gesture handling to SetRow component using pointer/touch events.

**Add local state for swipe tracking:**
```typescript
interface SwipeData {
  startX: number;
  startY: number;
  currentX: number;
  isDragging: boolean;
  pointerId: number | null;
}

const [swipeData, setSwipeData] = useState<SwipeData | null>(null);
const [isRevealed, setIsRevealed] = useState(false);
const wrapperRef = useRef<HTMLDivElement>(null);
const setRowRef = useRef<HTMLDivElement>(null);
```

**Add props for external reset (when tapping elsewhere):**
```typescript
interface SetRowProps {
  // ... existing props ...
  /** Whether this row should reset its swipe state */
  shouldResetSwipe?: boolean;
  /** Callback when swipe state changes */
  onSwipeStateChange?: (isRevealed: boolean) => void;
}
```

**Swipe handlers (from js/app.js lines 775-881):**

```typescript
const handleSwipeStart = (event: PointerEvent | TouchEvent): void => {
  // Don't interfere if clicking the delete button
  if ((event.target as HTMLElement).closest('.btn-remove-set')) {
    return;
  }

  // Close this row if already revealed
  if (isRevealed) {
    resetSwipe();
    return;
  }

  const clientX = 'touches' in event ? event.touches[0].clientX : event.clientX;
  const clientY = 'touches' in event ? event.touches[0].clientY : event.clientY;

  setSwipeData({
    startX: clientX,
    startY: clientY,
    currentX: clientX,
    isDragging: false,
    pointerId: 'pointerId' in event ? event.pointerId : null
  });

  // Capture pointer for smoother tracking
  if ('pointerId' in event && wrapperRef.current?.setPointerCapture) {
    wrapperRef.current.setPointerCapture(event.pointerId);
  }
};

const handleSwipeMove = (event: PointerEvent | TouchEvent): void => {
  if (!swipeData) return;

  const clientX = 'touches' in event ? event.touches[0].clientX : event.clientX;
  const clientY = 'touches' in event ? event.touches[0].clientY : event.clientY;

  const deltaX = clientX - swipeData.startX;
  const deltaY = clientY - swipeData.startY;

  // Only handle horizontal swipes
  if (!swipeData.isDragging && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 5) {
    setSwipeData(prev => prev ? { ...prev, isDragging: true } : null);
  }

  if (swipeData.isDragging) {
    // Prevent scrolling when swiping horizontally
    if ('cancelable' in event && event.cancelable) {
      event.preventDefault();
    }

    // Only allow swiping left, constrain to max distance
    const swipeDistance = Math.min(0, deltaX);
    const maxSwipe = -80;
    const constrainedDistance = Math.max(maxSwipe, swipeDistance);

    // Apply transform directly
    if (setRowRef.current) {
      setRowRef.current.style.transform = `translateX(${constrainedDistance}px)`;
    }

    setSwipeData(prev => prev ? { ...prev, currentX: clientX } : null);
  }
};

const handleSwipeEnd = (event: PointerEvent | TouchEvent): void => {
  if (!swipeData) return;

  const deltaX = swipeData.currentX - swipeData.startX;
  const threshold = -40;

  if (swipeData.isDragging && deltaX < threshold) {
    // Snap to revealed position
    setIsRevealed(true);
    if (setRowRef.current) {
      setRowRef.current.style.transform = 'translateX(-70px)';
    }
    onSwipeStateChange?.(true);
  } else {
    // Snap back to original
    resetSwipe();
  }

  // Release pointer capture
  if (swipeData.pointerId && wrapperRef.current?.releasePointerCapture) {
    try {
      wrapperRef.current.releasePointerCapture(swipeData.pointerId);
    } catch (e) {
      // Ignore if already released
    }
  }

  setSwipeData(null);
};

const resetSwipe = (): void => {
  setIsRevealed(false);
  if (setRowRef.current) {
    setRowRef.current.style.transform = '';
  }
  onSwipeStateChange?.(false);
};
```

**Effect to reset swipe when requested:**
```typescript
useEffect(() => {
  if (shouldResetSwipe && isRevealed) {
    resetSwipe();
  }
}, [shouldResetSwipe]);
```

**Update wrapper div to include event handlers:**
```tsx
<div
  ref={wrapperRef}
  class={`set-row-wrapper ${swipeData?.isDragging ? 'swiping' : ''} ${isRevealed ? 'swipe-revealed' : ''}`}
  onPointerDown={handleSwipeStart}
  onPointerMove={handleSwipeMove}
  onPointerUp={handleSwipeEnd}
  onPointerCancel={handleSwipeEnd}
  onTouchStart={handleSwipeStart}
  onTouchMove={handleSwipeMove}
  onTouchEnd={handleSwipeEnd}
  onClick={(e) => e.stopPropagation()}
>
  <div ref={setRowRef} class={`set-row ${set.is_done ? 'set-done' : ''}`}>
    ...
  </div>
  ...delete button...
</div>
```
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>SetRow has swipe gesture handlers with reveal/reset state management</done>
</task>

<task type="auto">
  <name>Task 2: Add swipe reset coordination to WorkoutSurface</name>
  <files>src/surfaces/workout/WorkoutSurface.tsx, src/surfaces/workout/WorkoutExerciseCard.tsx</files>
  <action>
Coordinate swipe state across all set rows to close revealed rows when clicking elsewhere.

**Add state in WorkoutSurface:**
```typescript
// Track which set row is currently revealed (if any)
const [revealedSetKey, setRevealedSetKey] = useState<string | null>(null);
```

**Add handler to close all revealed rows:**
```typescript
const handleSwipeCancel = (): void => {
  setRevealedSetKey(null);
};

// Handler for when a set row's swipe state changes
const handleSetSwipeStateChange = (exerciseIndex: number, setIndex: number, isRevealed: boolean): void => {
  if (isRevealed) {
    setRevealedSetKey(`${exerciseIndex}-${setIndex}`);
  } else if (revealedSetKey === `${exerciseIndex}-${setIndex}`) {
    setRevealedSetKey(null);
  }
};
```

**Add click handler to workout surface container:**
Match index.html line 524 - the workout surface has `@click="handleSwipeCancel()"`:
```tsx
<div class="workout-surface" onClick={handleSwipeCancel}>
  ...
</div>
```

**Update WorkoutExerciseCard props:**
```typescript
interface WorkoutExerciseCardProps {
  // ... existing props ...
  /** Key of the currently revealed set row (or null) */
  revealedSetKey: string | null;
  /** Callback when set swipe state changes */
  onSetSwipeStateChange: (setIndex: number, isRevealed: boolean) => void;
}
```

**Update SetRow rendering in WorkoutExerciseCard:**
```tsx
{exercise.sets.map((set, setIndex) => (
  <SetRow
    key={setIndex}
    set={set}
    exerciseIndex={exerciseIndex}
    setIndex={setIndex}
    canDelete={exercise.sets.length > 1}
    onWeightChange={onWeightChange}
    onRepsChange={onRepsChange}
    onToggleDone={() => onToggleDone(exerciseIndex, setIndex, exercise.rest_seconds)}
    onDelete={onDeleteSet}
    shouldResetSwipe={revealedSetKey !== `${exerciseIndex}-${setIndex}`}
    onSwipeStateChange={(isRevealed) => onSetSwipeStateChange(setIndex, isRevealed)}
  />
))}
```

**Update deleteSetWithSwipeReset:**
Combine set deletion with swipe reset:
```typescript
const handleDeleteSet = (exerciseIndex: number, setIndex: number): void => {
  // First close any revealed rows
  setRevealedSetKey(null);

  // Then delete the set
  setActiveWorkout(prev => {
    const updated = { ...prev };
    const exercise = updated.exercises[exerciseIndex];
    if (exercise.sets.length > 1) {
      exercise.sets = exercise.sets.filter((_, i) => i !== setIndex);
      exercise.sets.forEach((set, i) => set.set_number = i + 1);
    }
    return updated;
  });
};
```
  </action>
  <verify>npm run build succeeds, swiping set row left reveals delete button, tapping elsewhere closes it</verify>
  <done>Swipe state coordinated across all set rows, clicking outside closes revealed rows</done>
</task>

<task type="auto">
  <name>Task 3: Polish swipe interactions</name>
  <files>src/surfaces/workout/SetRow.tsx</files>
  <action>
Add finishing touches to swipe interactions.

**Ensure delete button is only visible when revealed:**
```tsx
<button
  type="button"
  class="btn-remove-set"
  onClick={(e) => {
    e.stopPropagation();
    onDelete(exerciseIndex, setIndex);
  }}
  style={{ visibility: canDelete && isRevealed ? 'visible' : 'hidden' }}
  title="Remove Set"
>
  {/* X icon SVG */}
</button>
```

**Prevent text selection during swipe:**
Add to wrapper style when dragging:
```typescript
const wrapperStyle = swipeData?.isDragging ? { userSelect: 'none' as const } : {};
```

**Add CSS class for swipe progress (for delete background visibility):**
The original code uses `--swipe-progress` CSS variable. Since we're using inline transforms, ensure the delete button positioning works with the transform.

**Test edge cases:**
- Quick tap shouldn't trigger swipe
- Vertical scroll shouldn't trigger horizontal swipe
- Multiple rows can't be revealed simultaneously
- Deleting a row clears its swipe state
  </action>
  <verify>npm run build succeeds, swipe gestures feel natural, delete button reveals/hides correctly</verify>
  <done>Swipe interactions polished, edge cases handled, delete reveal/hide works smoothly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] Swiping set row left reveals delete button
- [ ] Delete button click removes the set
- [ ] Tapping elsewhere closes revealed row
- [ ] Only one row can be revealed at a time
- [ ] Vertical scrolling doesn't trigger swipe
- [ ] Quick taps don't accidentally trigger swipe
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Swipe-to-delete gesture functional on all set rows
- Proper coordination (only one revealed at a time)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-workout-surface/09-04-SUMMARY.md`
</output>
