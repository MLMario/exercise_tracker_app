---
phase: 16-service-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/types/services.ts
  - packages/shared/src/services/exercises.ts
autonomous: true

must_haves:
  truths:
    - "Calling updateExercise with a valid exercise ID, name, and category persists the changes to the database"
    - "A user cannot update exercises created by other users or system exercises (RLS enforced, .single() catches empty result)"
    - "Calling getUserExercises returns only user-created exercises sorted alphabetically"
    - "Calling getExerciseDependencies returns counts of templates, workout logs, and charts referencing an exercise"
    - "Duplicate name check is case-insensitive, user-scoped, and excludes the exercise being updated"
    - "updateExercise returns typed validation errors (DUPLICATE_NAME, INVALID_NAME, EMPTY_NAME) not generic Error objects"
  artifacts:
    - path: "packages/shared/src/types/services.ts"
      provides: "UpdateExerciseParams, UpdateExerciseError, UpdateExerciseResult, ExerciseDependencies types and ExercisesService interface updates"
      contains: "UpdateExerciseResult"
    - path: "packages/shared/src/services/exercises.ts"
      provides: "updateExercise, getUserExercises, getExerciseDependencies functions"
      exports: ["exercises"]
  key_links:
    - from: "packages/shared/src/services/exercises.ts"
      to: "packages/shared/src/types/services.ts"
      via: "import type"
      pattern: "import type.*UpdateExerciseParams|UpdateExerciseResult|ExerciseDependencies"
    - from: "packages/shared/src/services/exercises.ts"
      to: "supabase.from('exercises')"
      via: "update query with .select().single()"
      pattern: "\\.update\\(.*\\.select\\(\\)\\.single\\(\\)"
    - from: "packages/shared/src/services/exercises.ts"
      to: "supabase.from('exercises').ilike().neq()"
      via: "uniqueness check"
      pattern: "\\.ilike\\('name'.*\\.neq\\('id'"
---

<objective>
Add three service functions (updateExercise, getUserExercises, getExerciseDependencies) and their supporting types to the shared package, completing backend infrastructure for exercise management.

Purpose: Phases 18-21 (Exercise List, Edit, Delete, Create) all depend on these service functions existing. This phase makes the backend fully ready before any UI work begins.
Output: Updated types/services.ts with new types and interface methods; updated services/exercises.ts with three new functions and updated export object.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-service-layer/16-CONTEXT.md
@.planning/phases/16-service-layer/16-RESEARCH.md
@packages/shared/src/types/services.ts
@packages/shared/src/types/database.ts
@packages/shared/src/services/exercises.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service types and update ExercisesService interface</name>
  <files>packages/shared/src/types/services.ts</files>
  <action>
Add the following new types in the Exercises Service Types section of services.ts, BEFORE the ExercisesService interface:

1. `UpdateExerciseParams` interface:
   - `id: string` (required)
   - `name?: string` (optional -- partial updates)
   - `category?: ExerciseCategory` (optional -- partial updates)

2. `UpdateExerciseError` type:
   - String literal union: `'DUPLICATE_NAME' | 'INVALID_NAME' | 'EMPTY_NAME'`

3. `UpdateExerciseResult` interface:
   - `data: Exercise | null`
   - `error: Error | null`
   - `validationError?: UpdateExerciseError`
   - This is a DEDICATED type (not extending ServiceResult) so the generic ServiceResult stays clean

4. `ExerciseDependencies` interface:
   - `templateCount: number`
   - `workoutLogCount: number`
   - `chartCount: number`

Then add three new method signatures to the `ExercisesService` interface (after `deleteExercise`):

5. `updateExercise(params: UpdateExerciseParams): Promise<UpdateExerciseResult>`
   - JSDoc: "Update an exercise's name and/or category. Returns typed validation errors for name issues."

6. `getUserExercises(): Promise<ServiceResult<Exercise[]>>`
   - JSDoc: "Get only user-created exercises, sorted alphabetically by name."

7. `getExerciseDependencies(exerciseId: string): Promise<ServiceResult<ExerciseDependencies>>`
   - JSDoc: "Get counts of templates, workout logs, and charts that reference an exercise."

Follow existing JSDoc style with @param and @returns. Add ExerciseCategory to the database import if not already present (it IS already imported -- verify and use it).
  </action>
  <verify>Run `npx tsc --noEmit` from the packages/shared directory. The new types must compile without errors. The ExercisesService interface will show errors because the implementation does not yet have the new methods -- this is expected and will be fixed in Task 2.</verify>
  <done>services.ts contains UpdateExerciseParams, UpdateExerciseError, UpdateExerciseResult, ExerciseDependencies types and ExercisesService interface has three new method signatures.</done>
</task>

<task type="auto">
  <name>Task 2: Implement updateExercise, getUserExercises, getExerciseDependencies functions</name>
  <files>packages/shared/src/services/exercises.ts</files>
  <action>
Add three new functions to exercises.ts and update the export object. Follow the exact patterns from createExercise for auth checks, error handling, and return structure. Import the new types from '../types/services'.

**Function 1: updateExercise(params: UpdateExerciseParams): Promise&lt;UpdateExerciseResult&gt;**

Implementation (follow RESEARCH.md code example closely):
1. Auth check: `supabase.auth.getUser()`, return error if no user
2. Destructure `{ id, name, category }` from params
3. Build update object conditionally (only include provided fields) to avoid overwriting with undefined
4. If `name` is provided:
   a. Trim whitespace FIRST: `const trimmedName = name.trim()`
   b. Reject empty: if `!trimmedName`, return `{ data: null, error: null, validationError: 'EMPTY_NAME' }`
   c. Validate characters: if `!/^[a-zA-Z0-9 ]+$/.test(trimmedName)`, return `{ data: null, error: null, validationError: 'INVALID_NAME' }`
   d. Case-insensitive uniqueness check, user-scoped, self-excluding:
      ```
      supabase.from('exercises').select('id')
        .eq('user_id', user.id)
        .eq('is_system', false)
        .ilike('name', trimmedName)
        .neq('id', id)
        .maybeSingle()
      ```
      If existing row found, return `{ data: null, error: null, validationError: 'DUPLICATE_NAME' }`
   e. Set `updateData.name = trimmedName`
5. If `category` is provided, set `updateData.category = category`
6. If updateData is empty (no fields to update), return error: `new Error('No fields to update')`
7. Execute update: `supabase.from('exercises').update(updateData).eq('id', id).select().single()`
   - The `.single()` will error if RLS blocks the update (0 rows returned), providing the "not found or not editable" guard
8. Return `{ data: data as Exercise, error: null }`
9. Wrap all in try/catch per codebase pattern

**Function 2: getUserExercises(): Promise&lt;ServiceResult&lt;Exercise[]&gt;&gt;**

1. Auth check: `supabase.auth.getUser()`
2. Query: `supabase.from('exercises').select('*').eq('user_id', user.id).eq('is_system', false).order('name', { ascending: true })`
3. Return `{ data: data as Exercise[], error: null }`
4. Standard try/catch

**Function 3: getExerciseDependencies(exerciseId: string): Promise&lt;ServiceResult&lt;ExerciseDependencies&gt;&gt;**

1. Run three count queries in parallel with `Promise.all`:
   - `supabase.from('template_exercises').select('*', { count: 'exact', head: true }).eq('exercise_id', exerciseId)`
   - `supabase.from('workout_log_exercises').select('*', { count: 'exact', head: true }).eq('exercise_id', exerciseId)`
   - `supabase.from('user_charts').select('*', { count: 'exact', head: true }).eq('exercise_id', exerciseId)`
2. Check for first error among results
3. Return `{ data: { templateCount: count ?? 0, workoutLogCount: count ?? 0, chartCount: count ?? 0 }, error: null }`
4. Standard try/catch

**Update exports:**
Add all three functions to the `exercises` export object at the bottom of the file:
```
export const exercises: ExercisesService = {
  getExercises,
  getExercisesByCategory,
  getExercisesWithLoggedData,
  createExercise,
  deleteExercise,
  exerciseExists,
  getCategories,
  updateExercise,
  getUserExercises,
  getExerciseDependencies,
};
```

**Update imports at top of file:**
Add `UpdateExerciseParams`, `UpdateExerciseResult`, and `ExerciseDependencies` to the type imports from '../types/services'. The `ExerciseDependencies` type is needed for the return type annotation.
  </action>
  <verify>Run `npx tsc --noEmit` from the monorepo root (or packages/shared). All files must compile with zero errors. The ExercisesService interface in types/services.ts must be fully satisfied by the exercises export object.</verify>
  <done>exercises.ts exports updateExercise (with input validation, case-insensitive uniqueness check, partial update support, typed validation errors), getUserExercises (user-scoped, alphabetical), and getExerciseDependencies (parallel count queries across 3 tables). TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors from monorepo root
2. The `exercises` export object satisfies the `ExercisesService` interface (no missing methods)
3. New types are accessible via `import { UpdateExerciseParams, UpdateExerciseResult, ExerciseDependencies } from '@ironlift/shared'` (barrel export chain: types/index.ts re-exports types/services.ts)
4. No new files created -- only two existing files modified
</verification>

<success_criteria>
- updateExercise handles partial updates (name only, category only, both)
- updateExercise trims whitespace before validation and uniqueness check
- updateExercise validates name characters (letters, numbers, spaces only)
- updateExercise checks case-insensitive name uniqueness scoped to user's exercises, excluding self
- updateExercise returns typed validation errors (DUPLICATE_NAME, INVALID_NAME, EMPTY_NAME)
- updateExercise uses .select().single() to catch RLS-blocked updates
- getUserExercises returns only user-created exercises (is_system=false, user_id=current user)
- getUserExercises sorts results alphabetically by name
- getExerciseDependencies returns counts from template_exercises, workout_log_exercises, and user_charts
- getExerciseDependencies runs all three count queries in parallel
- TypeScript compilation passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-service-layer/16-01-SUMMARY.md`
</output>
